;;; Common Lisp group theory package
(defpackage :groups
  (:use :common-lisp)
  (:export :additive-group
           :multiplicative-group
	   :permutation-group
	   :orders-alist
	   :subgroups
	   :print-cayley-table
	   :report))
(in-package :groups)

(defun index (n)
  "Procedure constructs list from 0 to n - 1 (0 based indexing)."
  (do ((i (1- n) (1- i))
       (loc nil (cons i loc)))
      ((< i 0) loc)))

(defun enumerate (a b)
  "Procedure enumerates interval from a to b as list of integers."
  (do ((i b (1- i))
       (loc nil (cons i loc)))
      ((< i a) loc)))

;;; e.g. (permute '(2 3 1) '(3 2 1)) => (1 3 2)
(defun permute (s1 s2)
  (do ((seq (reverse s2) (cdr seq))
       (loc nil (cons (nth (1- (car seq)) s1) loc)))
      ((null seq) loc)))

(defun flatmap (fn seq)
  "(1 2) (3 4) => (1 2 3 4)"
  (reduce #'append (mapcar fn seq)))

(defun permutations (seq)
  "Procedure constructs list of permutations of seq."
  (if (null seq)
      (list nil)
      (flatmap (lambda (x)
		 (mapcar #'(lambda (p) (cons x p))
			 (permutations (remove x seq))))
	       seq)))

(defun permutation-group (n)
  (cons
   (permutations (enumerate 1 n))
   #'(lambda (x) (permute (first x) (second x)))))

(defun order (group) (length (car group)))

;;; non-tail recursive version
;; (defun element-order-recur (e n g)
;;   "Recursively compute order of group element."
;;   (let ((op (cdr g)) (id (caar g)))
;;     (if (= n id)
;; 	1
;; 	(+ 1 (element-order-recur e (funcall op (list e n)) g)))))

;;; tail recursive version
;; (defun element-order-tail-recur (e k g res)
;;   "Tail recursively compute order of group element."
;;   (let ((op (cdr g)) (id (caar g)))
;;     (if (= k id)
;; 	res
;; 	(element-order-tail-recur e (funcall op (list e k)) g (+ res 1)))))

;; (defun beta (e g)
;;   (element-order-tail-recur e e g 1))

(defun element-order (e g)
  "Compute order of group (g) element (e)."
  (labels ((recur (k res)
	     (if (equalp k (caar g))
		 res
		 (recur (funcall (cdr g) (list e k)) (+ res 1)))))
    (recur e 1)))

;; (defun element-order (e g)
;;   "Compute order of group element."
;;   (element-order-recur e e g))

(defun orders-list (g)
  (mapcar #'(lambda (x) (element-order x g)) (car g)))

;;; do not sort for permutation groups
(defun orders-alist (g)
  (sort (pairlis (car g) (orders-list g)) #'< :key #'car))

(defun p-orders-alist (g)
  (pairlis (car g) (orders-list g)))

;;; apply those SICP lectures on layers of abstraction
(defmacro operation-modulo-n (op n)
  "Macro constructs operation (e.g. * or +) modulo n."
  `(lambda (args) (mod (reduce #',op args) ,n)))
;; e.g.
;; (funcall (operation-modulo-n + 10) '(5 7)) => 2
;; (funcall (operation-modulo-n * 10) '(5 7)) => 5

;;; e.g.
;;; (exponentiate #'+ 5 0 3 10) => 5
;;; (exponentiate #'* 2 1 10 10) => 4
(defun exponentiate (op x n)
  "Procedure implements exponentiation defined by group theory operation."
  (do ((i 1 (1+ i))
       (acc x (funcall op x acc)))
      ((equal i n) acc)))

(defun additive-group (n)
  "Procedure returns additive-group modulo n."
  (cons (index n) (operation-modulo-n + n)))

(defun divisors (n)
  "Procedure constructs list of divisors of n."
  (do ((k n (1- k))
       (loc nil (if (zerop (rem n k)) (cons k loc) loc)))
      ((zerop k) loc)))

;;; if this function returns nil then n is prime
(defun proper-divisors (n)
  "Procedure returns list of proper divisors of n."
  (butlast (cdr (divisors n))))

(defun coprime-p (x y)
  "Procedure predicate true when x and y are coprimes."
  (if (= (gcd x y) 1)
      t
      nil))

(defun residues (n)
  "Procedure returns list of co-primes of n."
  (do ((i n (1- i))
       (loc nil (if (coprime-p i n) (cons i loc) loc)))
      ((zerop i) loc)))

(defun multiplicative-group (n)
  "Procedure returns multiplicative group modulo n."
  (cons (residues n) (operation-modulo-n * n)))

(defun generate (element group)
  "Procedure generates subgroup generated by element of group."
  (let ((operation (cdr group)))
    (do ((loc
	  (list element)
	  (cons (funcall operation (list element (car loc))) loc)))
	((equal (car loc) (caar group)) (reverse loc)))))

(defun subgroups (group)
  "Function returns list of subgroups generated by elements of group."
  (do ((in (reverse (car group)) (cdr in))
       (out nil (cons (generate (car in) group) out)))
      ((null in) out)))

(defun distinct-subgroups (group)
  "Function removes duplicate sets from list of subgroups of group."
  (remove-duplicates
   (subgroups group)
   :test #'(lambda (x y) (null (set-exclusive-or x y)))))

(defun associative-p (group)
  "Procedure predicate is true when group is Abelian."
  (let ((elements (car group)) (op (cdr group)))
    (dolist (a elements)
      (dolist (b elements)
	(when (not (equalp (funcall op (list a b)) (funcall op (list b a))))
	  (return-from associative-p nil))))
    t))

(defun cyclic-p (group)
  "Procedure predicate is true when group is cyclic."
  (progn
    (dolist (element (car group))
      (when (equal (length (generate element group)) (length (car group)))
	(return-from cyclic-p t)))
    nil))

;;; pretty print Cayley Table auxiliary procedures
(defun get-field-width (g)
  (let ((estrs (mapcar #'write-to-string (car g))))
    (1+ (reduce #'max (mapcar #'length estrs)))))

(defun numeric-format-string (field-width)
  (concatenate 'string "~" (write-to-string field-width) "d"))

(defun symbol-format-string (field-width)
  (concatenate 'string "~" (write-to-string field-width) "@a"))

(defun print-cayley-table (g str)
  "Procedure pretty-prints Cayley Table of group g, str is op symbol."
  (let ((elements (car g))
	(operation (cdr g))
	(afmt (symbol-format-string (get-field-width g))))
    (progn
      (format t "~%~%")
      (format t "~&Cayley Table")
      (format t "~&")
      (format t afmt str)
      (dolist (e elements)
	(format t afmt (write-to-string e)))
      (dolist (i elements)
	(progn
	  (format t "~&")
	  (format t afmt (write-to-string i))
	  (dolist (j elements)
	    (format t afmt (write-to-string (funcall operation (list i j)))))))
      'done)))

(defun report (group symbol-string operation-string)
  "Procedure displays information about group."
  (let ((elements (car group))
	(order (order group)))
    (progn
      (format t "~&~a = ~S" symbol-string elements)
      (format t "~&|~a| = ~d" symbol-string order)
      ;;; print group Cayley Table
      (print-cayley-table group operation-string)
      ;;; determine whetner group is Abelian
      (format t "~%~%")
      (if (associative-p group)
	  (format t "~&~a is Abelian." symbol-string)
	  (format t "~&~a is not Abelian." symbol-string))
      ;;;determine whether group is cyclic
      (if (cyclic-p group)
	  (format t "~&~a is cyclic." symbol-string)
	  (format t "~&~a is not cyclic." symbol-string))
      ;;; generate subgroups
      (format t "~%~%")
      (format t "~&cyclic subgroups")
      (let ((sg (subgroups group)))
	(progn
	  (dolist (g sg)
	    (format t "~&<~d> = ~S" (car g) g))
	  (format t "~%~%")
	  (dolist (g sg)
	    (progn
	      (format t "~&|<~d>| = ~d" (car g) (length g))
	      ;; maybe add dfmt as in table later
	      (format t " ~a|~a|/|<~d>| = ~d"
		      #\tab symbol-string (car g) (/ order (length g)))
	      ))))
      (format t "~%~%")
      (format t "~&distict cyclic subgroups")
      (let ((dsg (distinct-subgroups group)))
	(progn
	  (dolist (sg dsg)
	    (format t "~&~S" sg))
	  (format t "~%~%")
	  (format t "~&no. of distinct subgroups = ~d" (length dsg))))
      (let ((d (divisors order)))
	(progn
	  (format t "~&divisors of |~a| = ~S" symbol-string d)
	  (format t "~&no. of divisors of |~a| = ~d" symbol-string (length d))))
      'done)))

